// Code generated by 'ccgo -export-externs X -hide __syscall0,__syscall1,__syscall2,__syscall3,__syscall4,__syscall5,__syscall6 -nostdinc -nostdlib -o ../musl_freebsd_amd64.go -pkgname libc -static-locals-prefix _s -Iarch/x86_64 -Iarch/generic -Iobj/src/internal -Isrc/include -Isrc/internal -Iobj/include -Iinclude copyright.c src/ctype/isalnum.c src/ctype/isalpha.c src/ctype/isdigit.c src/internal/floatscan.c src/internal/intscan.c src/internal/shgetc.c src/math/copysignl.c src/math/fabsl.c src/math/fmodl.c src/math/scalbn.c src/math/scalbnl.c src/stdio/__toread.c src/stdio/__uflow.c src/stdlib/strtod.c src/stdlib/strtol.c src/string/strdup.c', DO NOT EDIT.

package libc

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer

// musl as a whole is licensed under the following standard MIT license:
//
// ----------------------------------------------------------------------
// Copyright © 2005-2020 Rich Felker, et al.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ----------------------------------------------------------------------
//
// Authors/contributors include:
//
// A. Wilcox
// Ada Worcester
// Alex Dowad
// Alex Suykov
// Alexander Monakov
// Andre McCurdy
// Andrew Kelley
// Anthony G. Basile
// Aric Belsito
// Arvid Picciani
// Bartosz Brachaczek
// Benjamin Peterson
// Bobby Bingham
// Boris Brezillon
// Brent Cook
// Chris Spiegel
// Clément Vasseur
// Daniel Micay
// Daniel Sabogal
// Daurnimator
// David Carlier
// David Edelsohn
// Denys Vlasenko
// Dmitry Ivanov
// Dmitry V. Levin
// Drew DeVault
// Emil Renner Berthing
// Fangrui Song
// Felix Fietkau
// Felix Janda
// Gianluca Anzolin
// Hauke Mehrtens
// He X
// Hiltjo Posthuma
// Isaac Dunham
// Jaydeep Patil
// Jens Gustedt
// Jeremy Huntwork
// Jo-Philipp Wich
// Joakim Sindholt
// John Spencer
// Julien Ramseier
// Justin Cormack
// Kaarle Ritvanen
// Khem Raj
// Kylie McClain
// Leah Neukirchen
// Luca Barbato
// Luka Perkov
// M Farkas-Dyck (Strake)
// Mahesh Bodapati
// Markus Wichmann
// Masanori Ogino
// Michael Clark
// Michael Forney
// Mikhail Kremnyov
// Natanael Copa
// Nicholas J. Kain
// orc
// Pascal Cuoq
// Patrick Oppenlander
// Petr Hosek
// Petr Skocik
// Pierre Carrier
// Reini Urban
// Rich Felker
// Richard Pennington
// Ryan Fairfax
// Samuel Holland
// Segev Finer
// Shiz
// sin
// Solar Designer
// Stefan Kristiansson
// Stefan O'Rear
// Szabolcs Nagy
// Timo Teräs
// Trutz Behn
// Valentin Ochs
// Will Dietz
// William Haddon
// William Pitcock
//
// Portions of this software are derived from third-party works licensed
// under terms compatible with the above MIT license:
//
// The TRE regular expression implementation (src/regex/reg* and
// src/regex/tre*) is Copyright © 2001-2008 Ville Laurikari and licensed
// under a 2-clause BSD license (license text in the source files). The
// included version has been heavily modified by Rich Felker in 2012, in
// the interests of size, simplicity, and namespace cleanliness.
//
// Much of the math library code (src/math/* and src/complex/*) is
// Copyright © 1993,2004 Sun Microsystems or
// Copyright © 2003-2011 David Schultz or
// Copyright © 2003-2009 Steven G. Kargl or
// Copyright © 2003-2009 Bruce D. Evans or
// Copyright © 2008 Stephen L. Moshier or
// Copyright © 2017-2018 Arm Limited
// and labelled as such in comments in the individual source files. All
// have been licensed under extremely permissive terms.
//
// The ARM memcpy code (src/string/arm/memcpy.S) is Copyright © 2008
// The Android Open Source Project and is licensed under a two-clause BSD
// license. It was taken from Bionic libc, used on Android.
//
// The AArch64 memcpy and memset code (src/string/aarch64/*) are
// Copyright © 1999-2019, Arm Limited.
//
// The implementation of DES for crypt (src/crypt/crypt_des.c) is
// Copyright © 1994 David Burren. It is licensed under a BSD license.
//
// The implementation of blowfish crypt (src/crypt/crypt_blowfish.c) was
// originally written by Solar Designer and placed into the public
// domain. The code also comes with a fallback permissive license for use
// in jurisdictions that may not recognize the public domain.
//
// The smoothsort implementation (src/stdlib/qsort.c) is Copyright © 2011
// Valentin Ochs and is licensed under an MIT-style license.
//
// The x86_64 port was written by Nicholas J. Kain and is licensed under
// the standard MIT terms.
//
// The mips and microblaze ports were originally written by Richard
// Pennington for use in the ellcc project. The original code was adapted
// by Rich Felker for build system and code conventions during upstream
// integration. It is licensed under the standard MIT terms.
//
// The mips64 port was contributed by Imagination Technologies and is
// licensed under the standard MIT terms.
//
// The powerpc port was also originally written by Richard Pennington,
// and later supplemented and integrated by John Spencer. It is licensed
// under the standard MIT terms.
//
// All other files which have no copyright comments are original works
// produced specifically for use as part of this library, written either
// by Rich Felker, the main author of the library, or by one or more
// contibutors listed above. Details on authorship of individual files
// can be found in the git version control history of the project. The
// omission of copyright and license comments in each file is in the
// interest of source tree size.
//
// In addition, permission is hereby granted for all public header files
// (include/* and arch/*/bits/*) and crt files intended to be linked into
// applications (crt/*, ldso/dlstart.c, and arch/*/crt_arch.h) to omit
// the copyright notice and permission notice otherwise required by the
// license, and to use these files without any requirement of
// attribution. These files include substantial contributions from:
//
// Bobby Bingham
// John Spencer
// Nicholas J. Kain
// Rich Felker
// Richard Pennington
// Stefan Kristiansson
// Szabolcs Nagy
//
// all of whom have explicitly granted such permission.
//
// This file previously contained text expressing a belief that most of
// the files covered by the above exception were sufficiently trivial not
// to be subject to copyright, resulting in confusion over whether it
// negated the permissions granted in the license. In the spirit of
// permissive licensing, and of not having licensing issues being an
// obstacle to adoption, that text has been removed.
const ( /* copyright.c:194:1: */
	__musl__copyright__ = 0
)

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */

func __isspace(tls *TLS, _c int32) int32 { /* ctype.h:26:21: */
	return (Bool32((_c == ' ') || ((uint32(_c) - uint32('\t')) < uint32(5))))
}

type locale_t = uintptr /* alltypes.h:343:32 */

func Xisalnum(tls *TLS, c int32) int32 { /* isalnum.c:3:5: */
	return (Bool32((func() int32 {
		if 0 != 0 {
			return Xisalpha(tls, c)
		}
		return (Bool32((((uint32(c)) | uint32(32)) - uint32('a')) < uint32(26)))
	}() != 0) || (func() int32 {
		if 0 != 0 {
			return Xisdigit(tls, c)
		}
		return (Bool32(((uint32(c)) - uint32('0')) < uint32(10)))
	}() != 0)))
}

func X__isalnum_l(tls *TLS, c int32, l locale_t) int32 { /* isalnum.c:8:5: */
	return Xisalnum(tls, c)
}

func Xisalpha(tls *TLS, c int32) int32 { /* isalpha.c:4:5: */
	return (Bool32(((uint32(c) | uint32(32)) - uint32('a')) < uint32(26)))
}

func X__isalpha_l(tls *TLS, c int32, l locale_t) int32 { /* isalpha.c:9:5: */
	return Xisalpha(tls, c)
}

func Xisdigit(tls *TLS, c int32) int32 { /* isdigit.c:4:5: */
	return (Bool32((uint32(c) - uint32('0')) < uint32(10)))
}

func X__isdigit_l(tls *TLS, c int32, l locale_t) int32 { /* isdigit.c:9:5: */
	return Xisdigit(tls, c)
}

type uintptr_t = uint64 /* alltypes.h:55:24 */

type intptr_t = int64 /* alltypes.h:70:15 */

type int8_t = int8 /* alltypes.h:96:25 */

type int16_t = int16 /* alltypes.h:101:25 */

type int32_t = int32 /* alltypes.h:106:25 */

type int64_t = int64 /* alltypes.h:111:25 */

type intmax_t = int64 /* alltypes.h:116:25 */

type uint8_t = uint8 /* alltypes.h:121:25 */

type uint16_t = uint16 /* alltypes.h:126:25 */

type uint32_t = uint32 /* alltypes.h:131:25 */

type uint64_t = uint64 /* alltypes.h:136:25 */

type uintmax_t = uint64 /* alltypes.h:146:25 */

type int_fast8_t = int8_t   /* stdint.h:22:16 */
type int_fast64_t = int64_t /* stdint.h:23:17 */

type int_least8_t = int8_t   /* stdint.h:25:17 */
type int_least16_t = int16_t /* stdint.h:26:17 */
type int_least32_t = int32_t /* stdint.h:27:17 */
type int_least64_t = int64_t /* stdint.h:28:17 */

type uint_fast8_t = uint8_t   /* stdint.h:30:17 */
type uint_fast64_t = uint64_t /* stdint.h:31:18 */

type uint_least8_t = uint8_t   /* stdint.h:33:18 */
type uint_least16_t = uint16_t /* stdint.h:34:18 */
type uint_least32_t = uint32_t /* stdint.h:35:18 */
type uint_least64_t = uint64_t /* stdint.h:36:18 */

type int_fast16_t = int32_t   /* stdint.h:1:17 */
type int_fast32_t = int32_t   /* stdint.h:2:17 */
type uint_fast16_t = uint32_t /* stdint.h:3:18 */
type uint_fast32_t = uint32_t /* stdint.h:4:18 */

type ssize_t = int64 /* alltypes.h:65:15 */

type off_t = int64 /* alltypes.h:162:16 */

type _IO_FILE = struct {
	flags        uint32
	_            [4]byte
	rpos         uintptr
	rend         uintptr
	close        uintptr
	wend         uintptr
	wpos         uintptr
	mustbezero_1 uintptr
	wbase        uintptr
	read         uintptr
	write        uintptr
	seek         uintptr
	buf          uintptr
	buf_size     size_t
	prev         uintptr
	next         uintptr
	fd           int32
	pipe_pid     int32
	lockcount    int64
	mode         int32
	lock         int32
	lbf          int32
	_            [4]byte
	cookie       uintptr
	off          off_t
	getln_buf    uintptr
	mustbezero_2 uintptr
	shend        uintptr
	shlim        off_t
	shcnt        off_t
	prev_locked  uintptr
	next_locked  uintptr
	locale       uintptr
} /* alltypes.h:320:9 */

type FILE = _IO_FILE /* alltypes.h:320:25 */

type va_list = uintptr /* alltypes.h:326:27 */

type _G_fpos64_t = struct {
	_        [0]uint64
	__opaque [16]int8
} /* stdio.h:54:9 */

type fpos_t = _G_fpos64_t /* stdio.h:58:3 */

type float_t = float32 /* alltypes.h:29:15 */

type double_t = float64 /* alltypes.h:34:16 */

func __FLOAT_BITS(tls *TLS, __f float32) uint32 { /* math.h:55:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var __u struct {__f float32;} at bp, 4

	*(*float32)(unsafe.Pointer(bp /* &__u */)) = __f
	return *(*uint32)(unsafe.Pointer(bp /* &__u */))
}

func __DOUBLE_BITS(tls *TLS, __f float64) uint64 { /* math.h:61:36: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var __u struct {__f float64;} at bp, 8

	*(*float64)(unsafe.Pointer(bp /* &__u */)) = __f
	return *(*uint64)(unsafe.Pointer(bp /* &__u */))
}

type syscall_arg_t = int64 /* syscall.h:22:14 */

func scanexp(tls *TLS, f uintptr, pok int32) int64 { /* floatscan.c:37:18: */
	var c int32
	var x int32
	var y int64
	var neg int32 = 0

	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	if (c == '+') || (c == '-') {
		neg = (Bool32(c == '-'))
		c = func() int32 {
			if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()
		if ((uint32(c - '0')) >= 10) && (pok != 0) {
			if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
				(*FILE)(unsafe.Pointer(f)).rpos--
			} else {
			}
		}
	}
	if (uint32(c - '0')) >= 10 {
		if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
		return (-0x7fffffffffffffff - int64(1))
	}
	for x = 0; ((uint32(c - '0')) < 10) && (x < (0x7fffffff / 10)); c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		x = (((10 * x) + c) - '0')
	}
	for y = int64(x); ((uint32(c - '0')) < 10) && (y < (0x7fffffffffffffff / int64(100))); c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		y = (((int64(10) * y) + int64(c)) - int64('0'))
	}
	for ; (uint32(c - '0')) < 10; c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
	}
	if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	if neg != 0 {
		return -y
	}
	return y
}

func decfloat(tls *TLS, f uintptr, c int32, bits int32, emin int32, sign int32, pok int32) float64 { /* floatscan.c:64:20: */
	bp := tls.Alloc(512)
	defer tls.Free(512)

	// var x [128]uint32_t at bp, 512

	var i int32
	var j int32
	var k int32
	var a int32
	var z int32
	var lrp int64 = int64(0)
	var dc int64 = int64(0)
	var e10 int64 = int64(0)
	var lnz int32 = 0
	var gotdig int32 = 0
	var gotrad int32 = 0
	var rp int32
	var e2 int32
	var emax int32 = ((-emin - bits) + 3)
	var denormal int32 = 0
	var y float64
	var frac float64 = float64(0)
	var bias float64 = float64(0)

	j = 0
	k = 0

	// Don't let leading zeros consume buffer space
	for ; c == '0'; c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		gotdig = 1
	}
	if c == '.' {
		gotrad = 1
		for c = func() int32 {
			if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}(); c == '0'; c = func() int32 {
			if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}() {
			gotdig = 1
			lrp--
		}
	}

	*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */)) = uint32_t(0)
	for ; ((uint32(c - '0')) < 10) || (c == '.'); c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		if c == '.' {
			if gotrad != 0 {
				break
			}
			gotrad = 1
			lrp = dc
		} else if k < (128 - 3) {
			dc++
			if c != '0' {
				lnz = int32(dc)
			}
			if j != 0 {
				*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) = (((*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) * uint32_t(10)) + uint32_t(c)) - uint32_t('0'))
			} else {
				*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) = (uint32_t(c - '0'))
			}
			if PreIncInt32(&j, 1) == 9 {
				k++
				j = 0
			}
			gotdig = 1
		} else {
			dc++
			if c != '0' {
				lnz = ((128 - 4) * 9)
				*(*uint32_t)(unsafe.Pointer(bp /* &x */ + 124*4)) |= (uint32_t(1))
			}
		}
	}
	if !(gotrad != 0) {
		lrp = dc
	}

	if (gotdig != 0) && ((c | 32) == 'e') {
		e10 = scanexp(tls, f, pok)
		if e10 == (-0x7fffffffffffffff - int64(1)) {
			if pok != 0 {
				if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
					(*FILE)(unsafe.Pointer(f)).rpos--
				} else {
				}
			} else {
				X__shlim(tls, f, int64(0))
				return float64(0)
			}
			e10 = int64(0)
		}
		lrp = lrp + (e10)
	} else if c >= 0 {
		if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
	}
	if !(gotdig != 0) {
		(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 22
		X__shlim(tls, f, int64(0))
		return float64(0)
	}

	// Handle zero specially to avoid nasty special cases later
	if !(int32(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */))) != 0) {
		return (float64(sign) * 0.0)
	}

	// Optimize small integers (w/no exponent) and over/under-flow
	if ((lrp == dc) && (dc < int64(10))) && ((bits > 30) || ((*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */)) >> bits) == uint32_t(0))) {
		return (float64(sign) * float64(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */))))
	}
	if lrp > (int64(-emin / 2)) {
		(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
		return ((float64(sign) * 1.79769313486231570815e+308) * 1.79769313486231570815e+308)
	}
	if lrp < (int64(emin - (2 * 53))) {
		(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
		return ((float64(sign) * 2.22507385850720138309e-308) * 2.22507385850720138309e-308)
	}

	// Align incomplete final B1B digit
	if j != 0 {
		for ; j < 9; j++ {
			*(*uint32_t)(unsafe.Pointer(bp /* &x */ + uintptr(k)*4)) *= (uint32_t(10))
		}
		k++
		j = 0
	}

	a = 0
	z = k
	e2 = 0
	rp = int32(lrp)

	// Optimize small to mid-size integers (even in exp. notation)
	if ((lnz < 9) && (lnz <= rp)) && (rp < 18) {
		if rp == 9 {
			return (float64(sign) * float64(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */))))
		}
		if rp < 9 {
			return ((float64(sign) * float64(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */)))) / float64(_sp10s[(8-rp)]))
		}
		var bitlim int32 = (bits - (3 * (rp - 9)))
		if (bitlim > 30) || ((*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */)) >> bitlim) == uint32_t(0)) {
			return ((float64(sign) * float64(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */)))) * float64(_sp10s[(rp-10)]))
		}
	}

	// Drop trailing zeros
	for ; !(int32(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr((z-1))*4))) != 0); z-- {
	}

	// Align radix point to B1B digit boundary
	if (rp % 9) != 0 {
		var rpm9 int32
		if rp >= 0 {
			rpm9 = (rp % 9)
		} else {
			rpm9 = ((rp % 9) + 9)
		}
		var p10 int32 = _sp10s[(8 - rpm9)]
		var carry uint32_t = uint32_t(0)
		for k = a; k != z; k++ {
			var tmp uint32_t = (*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) % uint32_t(p10))
			*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) = ((*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) / uint32_t(p10)) + carry)
			carry = ((uint32_t(1000000000 / p10)) * tmp)
			if (k == a) && !(int32(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4))) != 0) {
				a = ((a + 1) & (128 - 1))
				rp = rp - (9)
			}
		}
		if carry != 0 {
			*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(PostIncInt32(&z, 1))*4)) = carry
		}
		rp = rp + (9 - rpm9)
	}

	// Upscale until desired number of bits are left of radix point
	for (rp < (9 * 2)) || ((rp == (9 * 2)) && (*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(a)*4)) < _sth[0])) {
		var carry uint32_t = uint32_t(0)
		e2 = e2 - (29)
		for k = ((z - 1) & (128 - 1)); ; k = ((k - 1) & (128 - 1)) {
			var tmp uint64_t = ((uint64_t(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4))) << 29) + uint64_t(carry))
			if tmp > uint64(1000000000) {
				carry = (uint32_t(tmp / uint64(1000000000)))
				*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) = (uint32_t(tmp % uint64(1000000000)))
			} else {
				carry = uint32_t(0)
				*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) = uint32_t(tmp)
			}
			if ((k == ((z - 1) & (128 - 1))) && (k != a)) && !(int32(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4))) != 0) {
				z = k
			}
			if k == a {
				break
			}
		}
		if carry != 0 {
			rp = rp + (9)
			a = ((a - 1) & (128 - 1))
			if a == z {
				z = ((z - 1) & (128 - 1))
				*(*uint32_t)(unsafe.Pointer(bp /* &x */ + uintptr(((z-1)&(128-1)))*4)) |= (*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(z)*4)))
			}
			*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(a)*4)) = carry
		}
	}

	// Downscale until exactly number of bits are left of radix point
	for {
		var carry uint32_t = uint32_t(0)
		var sh int32 = 1
		for i = 0; i < 2; i++ {
			k = ((a + i) & (128 - 1))
			if (k == z) || (*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) < _sth[i]) {
				i = 2
				break
			}
			if *(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(((a+i)&(128-1)))*4)) > _sth[i] {
				break
			}
		}
		if (i == 2) && (rp == (9 * 2)) {
			break
		}
		// FIXME: find a way to compute optimal sh
		if rp > (9 + (9 * 2)) {
			sh = 9
		}
		e2 = e2 + (sh)
		for k = a; k != z; k = ((k + 1) & (128 - 1)) {
			var tmp uint32_t = (*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) & (uint32_t((int32(1) << sh) - 1)))
			*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) = ((*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4)) >> sh) + carry)
			carry = ((uint32_t(int32(1000000000) >> sh)) * tmp)
			if (k == a) && !(int32(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(k)*4))) != 0) {
				a = ((a + 1) & (128 - 1))
				i--
				rp = rp - (9)
			}
		}
		if carry != 0 {
			if ((z + 1) & (128 - 1)) != a {
				*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(z)*4)) = carry
				z = ((z + 1) & (128 - 1))
			} else {
				*(*uint32_t)(unsafe.Pointer(bp /* &x */ + uintptr(((z-1)&(128-1)))*4)) |= (uint32_t(1))
			}
		}
	}

	// Assemble desired bits into floating point variable
	for y = float64(AssignInt32(&i, 0)); i < 2; i++ {
		if ((a + i) & (128 - 1)) == z {
			*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(((AssignInt32(&z, ((z+1)&(128-1))))-1))*4)) = uint32_t(0)
		}
		y = ((1000000000.0 * y) + float64(*(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(((a+i)&(128-1)))*4))))
	}

	y = y * (float64(sign))

	// Limit precision for denormal results
	if bits > ((53 + e2) - emin) {
		bits = ((53 + e2) - emin)
		if bits < 0 {
			bits = 0
		}
		denormal = 1
	}

	// Calculate bias term to force rounding, move out lower bits
	if bits < 53 {
		bias = Xcopysignl(tls, Xscalbn(tls, float64(1), (((2*53)-bits)-1)), y)
		frac = Xfmodl(tls, y, Xscalbn(tls, float64(1), (53-bits)))
		y = y - (frac)
		y = y + (bias)
	}

	// Process tail of decimal input so it can affect rounding
	if ((a + i) & (128 - 1)) != z {
		var t uint32_t = *(*uint32_t)(unsafe.Pointer(bp /* &x[0] */ + uintptr(((a+i)&(128-1)))*4))
		if (t < uint32_t(500000000)) && ((t != 0) || ((((a + i) + 1) & (128 - 1)) != z)) {
			frac = frac + (0.25 * float64(sign))
		} else if t > uint32_t(500000000) {
			frac = frac + (0.75 * float64(sign))
		} else if t == uint32_t(500000000) {
			if (((a + i) + 1) & (128 - 1)) == z {
				frac = frac + (0.5 * float64(sign))
			} else {
				frac = frac + (0.75 * float64(sign))
			}
		}
		if ((53 - bits) >= 2) && !(Xfmodl(tls, frac, float64(1)) != 0) {
			frac += 1
		}
	}

	y = y + (frac)
	y = y - (bias)

	if ((e2 + 53) & 0x7fffffff) > (emax - 5) {
		if Xfabsl(tls, y) >= (float64(float64(2)) / 2.22044604925031308085e-16) {
			if (denormal != 0) && (bits == ((53 + e2) - emin)) {
				denormal = 0
			}
			y = y * (0.5)
			e2++
		}
		if ((e2 + 53) > emax) || ((denormal != 0) && (frac != 0)) {
			(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
		}
	}

	return Xscalbnl(tls, y, e2)
}

var _sth = [2]uint32_t{uint32_t(9007199), uint32_t(254740991)} /* floatscan.c:67:24 */
var _sp10s = [8]int32{10, 100, 1000, 10000,
	100000, 1000000, 10000000, 100000000} /* floatscan.c:80:19 */

func hexfloat(tls *TLS, f uintptr, bits int32, emin int32, sign int32, pok int32) float64 { /* floatscan.c:315:20: */
	var x uint32_t = uint32_t(0)
	var y float64 = float64(0)
	var scale float64 = float64(1)
	var bias float64 = float64(0)
	var gottail int32 = 0
	var gotrad int32 = 0
	var gotdig int32 = 0
	var rp int64 = int64(0)
	var dc int64 = int64(0)
	var e2 int64 = int64(0)
	var d int32
	var c int32

	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()

	// Skip leading zeros
	for ; c == '0'; c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		gotdig = 1
	}

	if c == '.' {
		gotrad = 1
		c = func() int32 {
			if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()
		// Count zeros after the radix point before significand
		rp = int64(0)
	__1:
		if !(c == '0') {
			goto __3
		}
		gotdig = 1
		goto __2
	__2:
		c = func() int32 {
			if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()
		rp--
		goto __1
		goto __3
	__3:
	}

	for ; (((uint32(c - '0')) < 10) || ((uint32((c | 32) - 'a')) < 6)) || (c == '.'); c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		if c == '.' {
			if gotrad != 0 {
				break
			}
			rp = dc
			gotrad = 1
		} else {
			gotdig = 1
			if c > '9' {
				d = (((c | 32) + 10) - 'a')
			} else {
				d = (c - '0')
			}
			if dc < int64(8) {
				x = ((x * uint32_t(16)) + uint32_t(d))
			} else if dc < (int64((53 / 4) + 1)) {
				y = y + (float64(d) * (AssignDivFloat64(&scale, float64(16))))
			} else if (d != 0) && !(gottail != 0) {
				y = y + (0.5 * scale)
				gottail = 1
			}
			dc++
		}
	}
	if !(gotdig != 0) {
		if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
		if pok != 0 {
			if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
				(*FILE)(unsafe.Pointer(f)).rpos--
			} else {
			}
			if gotrad != 0 {
				if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
					(*FILE)(unsafe.Pointer(f)).rpos--
				} else {
				}
			}
		} else {
			X__shlim(tls, f, int64(0))
		}
		return (float64(sign) * 0.0)
	}
	if !(gotrad != 0) {
		rp = dc
	}
	for dc < int64(8) {
		x = x * (uint32_t(16))
		dc++
	}
	if (c | 32) == 'p' {
		e2 = scanexp(tls, f, pok)
		if e2 == (-0x7fffffffffffffff - int64(1)) {
			if pok != 0 {
				if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
					(*FILE)(unsafe.Pointer(f)).rpos--
				} else {
				}
			} else {
				X__shlim(tls, f, int64(0))
				return float64(0)
			}
			e2 = int64(0)
		}
	} else {
		if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
	}
	e2 = e2 + ((int64(4) * rp) - int64(32))

	if !(x != 0) {
		return (float64(sign) * 0.0)
	}
	if e2 > int64(-emin) {
		(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
		return ((float64(sign) * 1.79769313486231570815e+308) * 1.79769313486231570815e+308)
	}
	if e2 < (int64(emin - (2 * 53))) {
		(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
		return ((float64(sign) * 2.22507385850720138309e-308) * 2.22507385850720138309e-308)
	}

	for x < 0x80000000 {
		if y >= 0.5 {
			x = x + (x + uint32_t(1))
			y = y + (y - float64(1))
		} else {
			x = x + (x)
			y = y + (y)
		}
		e2--
	}

	if int64(bits) > ((int64(32) + e2) - int64(emin)) {
		bits = (int32((int64(32) + e2) - int64(emin)))
		if bits < 0 {
			bits = 0
		}
	}

	if bits < 53 {
		bias = Xcopysignl(tls, Xscalbn(tls, float64(1), (((32+53)-bits)-1)), float64(sign))
	}

	if ((bits < 32) && (y != 0)) && !((x & uint32_t(1)) != 0) {
		x++
		y = float64(0)
	}

	y = ((bias + (float64(sign) * float64(x))) + (float64(sign) * y))
	y = y - (bias)

	if !(y != 0) {
		(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
	}

	return Xscalbnl(tls, y, int32(e2))
}

func X__floatscan(tls *TLS, f uintptr, prec int32, pok int32) float64 { /* floatscan.c:427:13: */
	var sign int32 = 1
	var i size_t
	var bits int32
	var emin int32
	var c int32

	switch prec {
	case 0:
		bits = 24
		emin = ((-125) - bits)
		break
	case 1:
		bits = 53
		emin = ((-1021) - bits)
		break
	case 2:
		bits = 53
		emin = ((-1021) - bits)
		break
	default:
		return float64(0)
	}

	for __isspace(tls, AssignInt32(&c, func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}())) != 0 {
	}

	if (c == '+') || (c == '-') {
		sign = sign - (2 * (Bool32(c == '-')))
		c = func() int32 {
			if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()
	}

	for i = uint64(0); (i < uint64(8)) && ((c | 32) == int32(*(*int8)(unsafe.Pointer(ts /* "infinity" */ + uintptr(i))))); i++ {
		if i < uint64(7) {
			c = func() int32 {
				if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
					return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
				}
				return X__shgetc(tls, f)
			}()
		}
	}
	if ((i == uint64(3)) || (i == uint64(8))) || ((i > uint64(3)) && (pok != 0)) {
		if i != uint64(8) {
			if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
				(*FILE)(unsafe.Pointer(f)).rpos--
			} else {
			}
			if pok != 0 {
				for ; i > uint64(3); i-- {
					if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
						(*FILE)(unsafe.Pointer(f)).rpos--
					} else {
					}
				}
			}
		}
		return (float64(float32(sign) * X__builtin_inff(tls)))
	}
	if !(i != 0) {
		for i = uint64(0); (i < uint64(3)) && ((c | 32) == int32(*(*int8)(unsafe.Pointer(ts + 9 /* "nan" */ + uintptr(i))))); i++ {
			if i < uint64(2) {
				c = func() int32 {
					if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
						return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
					}
					return X__shgetc(tls, f)
				}()
			}
		}
	}
	if i == uint64(3) {
		if (func() int32 {
			if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()) != '(' {
			if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
				(*FILE)(unsafe.Pointer(f)).rpos--
			} else {
			}
			return float64(X__builtin_nanf(tls, ts+13 /* "" */))
		}
		for i = uint64(1); ; i++ {
			c = func() int32 {
				if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
					return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
				}
				return X__shgetc(tls, f)
			}()
			if ((((uint32(c - '0')) < 10) || ((uint32(c - 'A')) < 26)) || ((uint32(c - 'a')) < 26)) || (c == '_') {
				continue
			}
			if c == ')' {
				return float64(X__builtin_nanf(tls, ts+13 /* "" */))
			}
			if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
				(*FILE)(unsafe.Pointer(f)).rpos--
			} else {
			}
			if !(pok != 0) {
				(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 22
				X__shlim(tls, f, int64(0))
				return float64(0)
			}
			for PostDecUint64(&i, 1) != 0 {
				if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
					(*FILE)(unsafe.Pointer(f)).rpos--
				} else {
				}
			}
			return float64(X__builtin_nanf(tls, ts+13 /* "" */))
		}
		return float64(X__builtin_nanf(tls, ts+13 /* "" */))
	}

	if i != 0 {
		if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
		(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 22
		X__shlim(tls, f, int64(0))
		return float64(0)
	}

	if c == '0' {
		c = func() int32 {
			if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()
		if (c | 32) == 'x' {
			return hexfloat(tls, f, bits, emin, sign, pok)
		}
		if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
		c = '0'
	}

	return decfloat(tls, f, c, bits, emin, sign, pok)
}

// Lookup table for digit values. -1==255>=36 -> invalid
var table = [257]uint8{Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17), uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24),
	uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17), uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24),
	uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
} /* intscan.c:7:28 */

func X__intscan(tls *TLS, f uintptr, base uint32, pok int32, lim uint64) uint64 { /* intscan.c:26:20: */
	var val uintptr
	var c int32
	var neg int32
	var x uint32
	var y uint64
	var bs int32
	val = (uintptr(unsafe.Pointer(&table)) + uintptr(1))
	neg = 0
	if !((base > uint32(36)) || (base == uint32(1))) {
		goto __1
	}
	(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 22
	return uint64(0)
__1:
	;
__2:
	if !(__isspace(tls, AssignInt32(&c, func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}())) != 0) {
		goto __3
	}
	goto __2
__3:
	;
	if !((c == '+') || (c == '-')) {
		goto __4
	}
	neg = -(Bool32(c == '-'))
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
__4:
	;
	if !(((base == uint32(0)) || (base == uint32(16))) && (c == '0')) {
		goto __5
	}
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	if !((c | 32) == 'x') {
		goto __7
	}
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	if !(int32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) >= 16) {
		goto __9
	}
	if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	if !(pok != 0) {
		goto __10
	}
	if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	goto __11
__10:
	X__shlim(tls, f, int64(0))
__11:
	;
	return uint64(0)
__9:
	;
	base = uint32(16)
	goto __8
__7:
	if !(base == uint32(0)) {
		goto __12
	}
	base = uint32(8)
__12:
	;
__8:
	;
	goto __6
__5:
	if !(base == uint32(0)) {
		goto __13
	}
	base = uint32(10)
__13:
	;
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) >= base) {
		goto __14
	}
	if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	X__shlim(tls, f, int64(0))
	(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 22
	return uint64(0)
__14:
	;
__6:
	;
	if !(base == uint32(10)) {
		goto __15
	}
	x = uint32(0)
__17:
	if !(((uint32(c - '0')) < 10) && (x <= ((0xffffffff / uint32(10)) - uint32(1)))) {
		goto __19
	}
	x = ((x * uint32(10)) + (uint32(c - '0')))
	goto __18
__18:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __17
	goto __19
__19:
	;
	y = uint64(x)
__20:
	if !((((uint32(c - '0')) < 10) && (y <= (((2 * uint64(0x7fffffffffffffff)) + uint64(1)) / uint64(10)))) && ((uint64(10) * y) <= (((2 * uint64(0x7fffffffffffffff)) + uint64(1)) - (uint64(c - '0'))))) {
		goto __22
	}
	y = ((y * uint64(10)) + (uint64(c - '0')))
	goto __21
__21:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __20
	goto __22
__22:
	;
	if !((uint32(c - '0')) >= 10) {
		goto __23
	}
	goto done
__23:
	;
	goto __16
__15:
	if !(!((base & (base - uint32(1))) != 0)) {
		goto __24
	}
	bs = int32(*(*int8)(unsafe.Pointer(ts + 14 /* "\x00\x01\x02\x04\a\x03\x06\x05" */ + uintptr((((uint32(0x17) * base) >> 5) & uint32(7))))))
	x = uint32(0)
__26:
	if !((uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) && (x <= (0xffffffff / uint32(32)))) {
		goto __28
	}
	x = ((x << bs) | uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))))
	goto __27
__27:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __26
	goto __28
__28:
	;
	y = uint64(x)
__29:
	if !((uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) && (y <= (uint64(((2 * uint64(0x7fffffffffffffff)) + uint64(1))) >> bs))) {
		goto __31
	}
	y = ((y << bs) | uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c)))))
	goto __30
__30:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __29
	goto __31
__31:
	;
	goto __25
__24:
	x = uint32(0)
__32:
	if !((uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) && (x <= ((0xffffffff / uint32(36)) - uint32(1)))) {
		goto __34
	}
	x = ((x * base) + uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))))
	goto __33
__33:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __32
	goto __34
__34:
	;
	y = uint64(x)
__35:
	if !(((uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) && (y <= (((2 * uint64(0x7fffffffffffffff)) + uint64(1)) / uint64(base)))) && ((uint64(base) * y) <= (((2 * uint64(0x7fffffffffffffff)) + uint64(1)) - uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c))))))) {
		goto __37
	}
	y = ((y * uint64(base)) + uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c)))))
	goto __36
__36:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __35
	goto __37
__37:
	;
__25:
	;
__16:
	;
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) {
		goto __38
	}
__39:
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) {
		goto __41
	}
	goto __40
__40:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __39
	goto __41
__41:
	;
	(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
	y = lim
	if !((lim & uint64(1)) != 0) {
		goto __42
	}
	neg = 0
__42:
	;
__38:
	;
done:
	if (*FILE)(unsafe.Pointer((f))).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	if !(y >= lim) {
		goto __43
	}
	if !(!((lim & uint64(1)) != 0) && !(neg != 0)) {
		goto __44
	}
	(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
	return (lim - uint64(1))
	goto __45
__44:
	if !(y > lim) {
		goto __46
	}
	(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
	return lim
__46:
	;
__45:
	;
__43:
	;
	return ((y ^ uint64(neg)) - uint64(neg))
}

// The shcnt field stores the number of bytes read so far, offset by
// the value of buf-rpos at the last function call (__shlim or __shgetc),
// so that between calls the inline shcnt macro can add rpos-buf to get
// the actual count.

func X__shlim(tls *TLS, f uintptr, lim off_t) { /* shgetc.c:8:6: */
	(*FILE)(unsafe.Pointer(f)).shlim = lim
	(*FILE)(unsafe.Pointer(f)).shcnt = ((int64((*FILE)(unsafe.Pointer(f)).buf) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1)
	// If lim is nonzero, rend must be a valid pointer.
	if (lim != 0) && (((int64((*FILE)(unsafe.Pointer(f)).rend) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1) > lim) {
		(*FILE)(unsafe.Pointer(f)).shend = ((*FILE)(unsafe.Pointer(f)).rpos + uintptr(lim))
	} else {
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rend
	}
}

func X__shgetc(tls *TLS, f uintptr) int32 { /* shgetc.c:19:5: */
	var c int32
	var cnt off_t = ((*FILE)(unsafe.Pointer((f))).shcnt + ((int64((*FILE)(unsafe.Pointer((f))).rpos) - int64((*FILE)(unsafe.Pointer((f))).buf)) / 1))
	if (((*FILE)(unsafe.Pointer(f)).shlim != 0) && (cnt >= (*FILE)(unsafe.Pointer(f)).shlim)) || ((AssignInt32(&c, X__uflow(tls, f))) < 0) {
		(*FILE)(unsafe.Pointer(f)).shcnt = (((int64((*FILE)(unsafe.Pointer(f)).buf) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1) + cnt)
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rpos
		(*FILE)(unsafe.Pointer(f)).shlim = int64(-1)
		return -1
	}
	cnt++
	if ((*FILE)(unsafe.Pointer(f)).shlim != 0) && (((int64((*FILE)(unsafe.Pointer(f)).rend) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1) > ((*FILE)(unsafe.Pointer(f)).shlim - cnt)) {
		(*FILE)(unsafe.Pointer(f)).shend = ((*FILE)(unsafe.Pointer(f)).rpos + uintptr(((*FILE)(unsafe.Pointer(f)).shlim - cnt)))
	} else {
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rend
	}
	(*FILE)(unsafe.Pointer(f)).shcnt = (((int64((*FILE)(unsafe.Pointer(f)).buf) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1) + cnt)
	if (*FILE)(unsafe.Pointer(f)).rpos <= (*FILE)(unsafe.Pointer(f)).buf {
		*(*uint8)(unsafe.Pointer((*FILE)(unsafe.Pointer(f)).rpos + UintptrFromInt32(-1))) = uint8(c)
	}
	return c
}

func __bswap32(tls *TLS, __x uint32_t) uint32_t { /* endian.h:24:26: */
	return ((((__x >> 24) | ((__x >> 8) & uint32_t(0xff00))) | ((__x << 8) & uint32_t(0xff0000))) | (__x << 24))
}

func Xcopysignl(tls *TLS, x float64, y float64) float64 { /* copysignl.c:4:13: */
	return Xcopysign(tls, x, y)
}

func Xfabsl(tls *TLS, x float64) float64 { /* fabsl.c:3:13: */
	return Xfabs(tls, x)
}

func Xfmodl(tls *TLS, x float64, y float64) float64 { /* fmodl.c:4:13: */
	return Xfmod(tls, x, y)
}

func Xscalbn(tls *TLS, x float64, n int32) float64 { /* scalbn.c:4:8: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var u struct {f float64;} at bp, 8

	var y double_t = x

	if n > 1023 {
		y = y * (0x1p1023)
		n = n - (1023)
		if n > 1023 {
			y = y * (0x1p1023)
			n = n - (1023)
			if n > 1023 {
				n = 1023
			}
		}
	} else if n < -1022 {
		// make sure final n < -53 to avoid double
		// 		   rounding in the subnormal range
		y = y * (float64(0x1p-1022) * 0x1p53)
		n = n + (1022 - 53)
		if n < -1022 {
			y = y * (float64(0x1p-1022) * 0x1p53)
			n = n + (1022 - 53)
			if n < -1022 {
				n = -1022
			}
		}
	}
	*(*uint64_t)(unsafe.Pointer(bp /* &u */)) = ((uint64_t(0x3ff + n)) << 52)
	x = (y * *(*float64)(unsafe.Pointer(bp /* &u */)))
	return x
}

func Xscalbnl(tls *TLS, x float64, n int32) float64 { /* scalbnl.c:4:13: */
	return Xscalbn(tls, x, n)
}

func X__toread(tls *TLS, f uintptr) int32 { /* __toread.c:3:5: */
	*(*int32)(unsafe.Pointer(f + 136 /* &.mode */)) |= ((*FILE)(unsafe.Pointer(f)).mode - 1)
	if (*FILE)(unsafe.Pointer(f)).wpos != (*FILE)(unsafe.Pointer(f)).wbase {
		(*(*func(*TLS, uintptr, uintptr, size_t) size_t)(unsafe.Pointer((f + 72 /* &.write */))))(tls, f, uintptr(0), uint64(0))
	}
	(*FILE)(unsafe.Pointer(f)).wpos = AssignPtrUintptr(f+56 /* &.wbase */, AssignPtrUintptr(f+32 /* &.wend */, uintptr(0)))
	if ((*FILE)(unsafe.Pointer(f)).flags & uint32(4)) != 0 {
		*(*uint32)(unsafe.Pointer(f /* &.flags */)) |= (uint32(32))
		return -1
	}
	(*FILE)(unsafe.Pointer(f)).rpos = AssignPtrUintptr(f+16 /* &.rend */, ((*FILE)(unsafe.Pointer(f)).buf + uintptr((*FILE)(unsafe.Pointer(f)).buf_size)))
	if ((*FILE)(unsafe.Pointer(f)).flags & uint32(16)) != 0 {
		return -1
	}
	return 0
}

func X__toread_needs_stdio_exit(tls *TLS) { /* __toread.c:16:13: */
	X__builtin_abort(tls) //TODO-
	// __stdio_exit_needed();
}

// This function assumes it will never be called if there is already
// data buffered for reading.

func X__uflow(tls *TLS, f uintptr) int32 { /* __uflow.c:6:5: */
	bp := tls.Alloc(1)
	defer tls.Free(1)

	// var c uint8 at bp, 1

	if !(X__toread(tls, f) != 0) && ((*(*func(*TLS, uintptr, uintptr, size_t) size_t)(unsafe.Pointer((f + 64 /* &.read */))))(tls, f, bp /* &c */, uint64(1)) == uint64(1)) {
		return int32(*(*uint8)(unsafe.Pointer(bp /* c */)))
	}
	return -1
}

type div_t = struct {
	quot int32
	rem  int32
} /* stdlib.h:62:35 */
type ldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:63:36 */
type lldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:64:41 */

func strtox(tls *TLS, s uintptr, p uintptr, prec int32) float64 { /* strtod.c:6:20: */
	bp := tls.Alloc(232)
	defer tls.Free(232)

	// var f FILE at bp, 232

	(*FILE)(unsafe.Pointer(bp /* &f */)).buf = AssignPtrUintptr(bp /* &f */ +8 /* &.rpos */, s)
	(*FILE)(unsafe.Pointer(bp /* &f */)).rend = UintptrFromInt32(-1)
	X__shlim(tls, bp /* &f */, int64(0))
	var y float64 = X__floatscan(tls, bp /* &f */, prec, 1)
	var cnt off_t = ((*FILE)(unsafe.Pointer((bp /* &f */))).shcnt + ((int64((*FILE)(unsafe.Pointer((bp /* &f */))).rpos) - int64((*FILE)(unsafe.Pointer((bp /* &f */))).buf)) / 1))
	if p != 0 {
		*(*uintptr)(unsafe.Pointer(p)) = func() uintptr {
			if cnt != 0 {
				return (s + uintptr(cnt))
			}
			return s
		}()
	}
	return y
}

func Xstrtof(tls *TLS, s uintptr, p uintptr) float32 { /* strtod.c:17:7: */
	return float32(strtox(tls, s, p, 0))
}

func Xstrtod(tls *TLS, s uintptr, p uintptr) float64 { /* strtod.c:22:8: */
	return strtox(tls, s, p, 1)
}

func Xstrtold(tls *TLS, s uintptr, p uintptr) float64 { /* strtod.c:27:13: */
	return strtox(tls, s, p, 2)
}

type imaxdiv_t = struct {
	quot intmax_t
	rem  intmax_t
} /* inttypes.h:14:40 */

func strtox1(tls *TLS, s uintptr, p uintptr, base int32, lim uint64) uint64 { /* strtol.c:8:27: */
	bp := tls.Alloc(232)
	defer tls.Free(232)

	// var f FILE at bp, 232

	(*FILE)(unsafe.Pointer(bp /* &f */)).buf = AssignPtrUintptr(bp /* &f */ +8 /* &.rpos */, s)
	(*FILE)(unsafe.Pointer(bp /* &f */)).rend = UintptrFromInt32(-1)
	X__shlim(tls, bp /* &f */, int64(0))
	var y uint64 = X__intscan(tls, bp /* &f */, uint32(base), 1, lim)
	if p != 0 {
		var cnt size_t = (size_t((*FILE)(unsafe.Pointer((bp /* &f */))).shcnt + ((int64((*FILE)(unsafe.Pointer((bp /* &f */))).rpos) - int64((*FILE)(unsafe.Pointer((bp /* &f */))).buf)) / 1)))
		*(*uintptr)(unsafe.Pointer(p)) = (s + uintptr(cnt))
	}
	return y
}

func Xstrtoull(tls *TLS, s uintptr, p uintptr, base int32) uint64 { /* strtol.c:21:20: */
	return strtox1(tls, s, p, base, ((2 * uint64(0x7fffffffffffffff)) + uint64(1)))
}

func Xstrtoll(tls *TLS, s uintptr, p uintptr, base int32) int64 { /* strtol.c:26:11: */
	return int64(strtox1(tls, s, p, base, (Uint64FromInt64(-0x7fffffffffffffff - int64(1)))))
}

func Xstrtoul(tls *TLS, s uintptr, p uintptr, base int32) uint64 { /* strtol.c:31:15: */
	return uint64(strtox1(tls, s, p, base, ((2 * uint64(0x7fffffffffffffff)) + uint64(1))))
}

func Xstrtol(tls *TLS, s uintptr, p uintptr, base int32) int64 { /* strtol.c:36:6: */
	return int64(strtox1(tls, s, p, base, (0 + (Uint64FromInt64(Int64(-Int64(0x7fffffffffffffff)) - Int64FromInt32(1))))))
}

func Xstrtoimax(tls *TLS, s uintptr, p uintptr, base int32) intmax_t { /* strtol.c:41:10: */
	return intmax_t(Xstrtoll(tls, s, p, base))
}

func Xstrtoumax(tls *TLS, s uintptr, p uintptr, base int32) uintmax_t { /* strtol.c:46:11: */
	return uintmax_t(Xstrtoull(tls, s, p, base))
}

func Xstrdup(tls *TLS, s uintptr) uintptr { /* strdup.c:4:6: */
	var l size_t = Xstrlen(tls, s)
	var d uintptr = Xmalloc(tls, (l + uint64(1)))
	if !(d != 0) {
		return uintptr(0)
	}
	return Xmemcpy(tls, d, s, (l + uint64(1)))
}

var ts1 = "infinity\x00nan\x00\x00\x00\x01\x02\x04\a\x03\x06\x05\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
