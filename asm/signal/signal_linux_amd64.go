// Code generated by 'ccgo -D__signed__=signed -ccgo-crt-import-path "" -ccgo-export-defines "" -ccgo-export-enums "" -ccgo-export-externs X -ccgo-export-fields F -ccgo-export-structs "" -ccgo-export-typedefs "" -ccgo-host-config-cmd "" -ccgo-host-config-opts "" -ccgo-long-double-is-double -ccgo-pkgname signal -o asm/signal/signal_linux_amd64.go', DO NOT EDIT.

package signal

import (
	"math"
	"reflect"
	"unsafe"
)

var _ = math.Pi
var _ reflect.Kind
var _ unsafe.Pointer

const (
	CLOCKS_MASK                = 1
	CLOCKS_MONO                = 1
	CLOCK_BOOTTIME             = 7
	CLOCK_BOOTTIME_ALARM       = 9
	CLOCK_MONOTONIC            = 1
	CLOCK_MONOTONIC_COARSE     = 6
	CLOCK_MONOTONIC_RAW        = 4
	CLOCK_PROCESS_CPUTIME_ID   = 2
	CLOCK_REALTIME             = 0
	CLOCK_REALTIME_ALARM       = 8
	CLOCK_REALTIME_COARSE      = 5
	CLOCK_SGI_CYCLE            = 10
	CLOCK_TAI                  = 11
	CLOCK_THREAD_CPUTIME_ID    = 3
	ITIMER_PROF                = 2
	ITIMER_REAL                = 0
	ITIMER_VIRTUAL             = 1
	MAX_CLOCKS                 = 16
	MINSIGSTKSZ                = 2048
	NSIG                       = 32
	SA_NOCLDSTOP               = 0x00000001
	SA_NOCLDWAIT               = 0x00000002
	SA_NODEFER                 = 0x40000000
	SA_NOMASK                  = 1073741824
	SA_ONESHOT                 = 2147483648
	SA_ONSTACK                 = 0x08000000
	SA_RESETHAND               = 0x80000000
	SA_RESTART                 = 0x10000000
	SA_RESTORER                = 0x04000000
	SA_SIGINFO                 = 0x00000004
	SIGABRT                    = 6
	SIGALRM                    = 14
	SIGBUS                     = 7
	SIGCHLD                    = 17
	SIGCONT                    = 18
	SIGFPE                     = 8
	SIGHUP                     = 1
	SIGILL                     = 4
	SIGINT                     = 2
	SIGIO                      = 29
	SIGIOT                     = 6
	SIGKILL                    = 9
	SIGPIPE                    = 13
	SIGPOLL                    = 29
	SIGPROF                    = 27
	SIGPWR                     = 30
	SIGQUIT                    = 3
	SIGRTMIN                   = 32
	SIGSEGV                    = 11
	SIGSTKFLT                  = 16
	SIGSTKSZ                   = 8192
	SIGSTOP                    = 19
	SIGSYS                     = 31
	SIGTERM                    = 15
	SIGTRAP                    = 5
	SIGTSTP                    = 20
	SIGTTIN                    = 21
	SIGTTOU                    = 22
	SIGUNUSED                  = 31
	SIGURG                     = 23
	SIGUSR1                    = 10
	SIGUSR2                    = 12
	SIGVTALRM                  = 26
	SIGWINCH                   = 28
	SIGXCPU                    = 24
	SIGXFSZ                    = 25
	SIG_BLOCK                  = 0
	SIG_SETMASK                = 2
	SIG_UNBLOCK                = 1
	TIMER_ABSTIME              = 0x01
	X_ASM_GENERIC_INT_LL64_H   = 0
	X_ASM_GENERIC_TYPES_H      = 0
	X_ASM_X86_POSIX_TYPES_64_H = 0
	X_ASM_X86_SIGNAL_H         = 0
	X_ASM_X86_TYPES_H          = 0
	X_LINUX_POSIX_TYPES_H      = 0
	X_LINUX_TIME_H             = 0
	X_LINUX_TYPES_H            = 0
	X_LP64                     = 1
	X_STDC_PREDEF_H            = 1
	X_STRUCT_TIMESPEC          = 0
	Linux                      = 1
	Unix                       = 1
)

type Ptrdiff_t = int64 /* <builtin>:3:26 */

type Size_t = uint64 /* <builtin>:9:23 */

type Wchar_t = int32 /* <builtin>:15:24 */

type X__builtin_va_list = uintptr /* <builtin>:28:14 */
type X__float128 = float64        /* <builtin>:29:21 */

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// SPDX-License-Identifier: GPL-2.0

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
// int-ll64 is used everywhere now.
// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
// asm-generic/int-ll64.h
//
// Integer declarations for architectures which use "long long"
// for 64-bit types.

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// There seems to be no way of detecting this automatically from user
// space, so 64 bit architectures should override this in their
// bitsperlong.h. In particular, an architecture that supports
// both 32 and 64 bit user space must not rely on CONFIG_64BIT
// to decide it, but rather check a compiler provided macro.

// __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
// header files exported to user space

type X__s8 = int8  /* int-ll64.h:20:25 */
type X__u8 = uint8 /* int-ll64.h:21:23 */

type X__s16 = int16  /* int-ll64.h:23:26 */
type X__u16 = uint16 /* int-ll64.h:24:24 */

type X__s32 = int32  /* int-ll64.h:26:24 */
type X__u32 = uint32 /* int-ll64.h:27:22 */

type X__s64 = int64  /* int-ll64.h:33:30 */
type X__u64 = uint64 /* int-ll64.h:34:28 */

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// This allows for 1024 file descriptors: if NR_OPEN is ever grown
// beyond that you'll have to change this too. But 1024 fd's seem to be
// enough even for such "real" unices like OSF/1, so hopefully this is
// one limit that doesn't have to be changed [again].
//
// Note that POSIX wants the FD_CLEAR(fd,fdsetp) defines to be in
// <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
// place for them. Solved by having dummy defines in <sys/time.h>.

// This macro may have been defined in <gnu/types.h>. But we always
// use the one here.

type X__kernel_fd_set = struct{ Ffds_bits [16]uint64 } /* posix_types.h:27:3 */

// Type of a signal handler.
type X__kernel_sighandler_t = uintptr /* posix_types.h:30:14 */

// Type of a SYSV IPC key.
type X__kernel_key_t = int32 /* posix_types.h:33:13 */
type X__kernel_mqd_t = int32 /* posix_types.h:34:13 */

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// This file is generally used by user-level software, so you need to
// be a little careful about namespace pollution etc.  Also, we cannot
// assume GCC is being used.

type X__kernel_old_uid_t = uint16 /* posix_types_64.h:11:24 */
type X__kernel_old_gid_t = uint16 /* posix_types_64.h:12:24 */

type X__kernel_old_dev_t = uint64 /* posix_types_64.h:15:23 */

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// This file is generally used by user-level software, so you need to
// be a little careful about namespace pollution etc.
//
// First the types that are often defined in different ways across
// architectures, so that you can override them.

type X__kernel_long_t = int64   /* posix_types.h:15:15 */
type X__kernel_ulong_t = uint64 /* posix_types.h:16:23 */

type X__kernel_ino_t = X__kernel_ulong_t /* posix_types.h:20:26 */

type X__kernel_mode_t = uint32 /* posix_types.h:24:22 */

type X__kernel_pid_t = int32 /* posix_types.h:28:14 */

type X__kernel_ipc_pid_t = int32 /* posix_types.h:32:14 */

type X__kernel_uid_t = uint32 /* posix_types.h:36:22 */
type X__kernel_gid_t = uint32 /* posix_types.h:37:22 */

type X__kernel_suseconds_t = X__kernel_long_t /* posix_types.h:41:26 */

type X__kernel_daddr_t = int32 /* posix_types.h:45:14 */

type X__kernel_uid32_t = uint32 /* posix_types.h:49:22 */
type X__kernel_gid32_t = uint32 /* posix_types.h:50:22 */

// Most 32 bit architectures use "unsigned int" size_t,
// and all 64 bit architectures use "unsigned long" size_t.
type X__kernel_size_t = X__kernel_ulong_t   /* posix_types.h:72:26 */
type X__kernel_ssize_t = X__kernel_long_t   /* posix_types.h:73:25 */
type X__kernel_ptrdiff_t = X__kernel_long_t /* posix_types.h:74:25 */

type X__kernel_fsid_t = struct{ Fval [2]int32 } /* posix_types.h:81:3 */

// anything below here should be completely generic
type X__kernel_off_t = X__kernel_long_t   /* posix_types.h:87:25 */
type X__kernel_loff_t = int64             /* posix_types.h:88:19 */
type X__kernel_time_t = X__kernel_long_t  /* posix_types.h:89:25 */
type X__kernel_time64_t = int64           /* posix_types.h:90:19 */
type X__kernel_clock_t = X__kernel_long_t /* posix_types.h:91:25 */
type X__kernel_timer_t = int32            /* posix_types.h:92:14 */
type X__kernel_clockid_t = int32          /* posix_types.h:93:14 */
type X__kernel_caddr_t = uintptr          /* posix_types.h:94:14 */
type X__kernel_uid16_t = uint16           /* posix_types.h:95:24 */
type X__kernel_gid16_t = uint16           /* posix_types.h:96:24 */

// Below are truly Linux-specific types that should never collide with
// any application/library that wants linux/types.h.

type X__le16 = X__u16 /* types.h:24:25 */
type X__be16 = X__u16 /* types.h:25:25 */
type X__le32 = X__u32 /* types.h:26:25 */
type X__be32 = X__u32 /* types.h:27:25 */
type X__le64 = X__u64 /* types.h:28:25 */
type X__be64 = X__u64 /* types.h:29:25 */

type X__sum16 = X__u16 /* types.h:31:25 */
type X__wsum = X__u32  /* types.h:32:25 */

// aligned_u64 should be used in defining kernel<->userspace ABIs to avoid
// common 32/64-bit compat problems.
// 64-bit values align to 4-byte boundaries on x86_32 (and possibly other
// architectures) and to 8-byte boundaries on 64-bit architectures.  The new
// aligned_64 type enforces 8-byte alignment so that structs containing
// aligned_64 values have the same alignment on 32-bit and 64-bit architectures.
// No conversions are necessary between 32-bit user-space and a 64-bit kernel.

type X__poll_t = uint32 /* types.h:47:28 */

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

type Timespec = struct {
	Ftv_sec  X__kernel_time_t
	Ftv_nsec int64
}

type Timeval = struct {
	Ftv_sec  X__kernel_time_t
	Ftv_usec X__kernel_suseconds_t
}

type Timezone = struct {
	Ftz_minuteswest int32
	Ftz_dsttime     int32
}

// Names of the interval timers, and structure
// defining a timer setting:

type Itimerspec = struct {
	Fit_interval struct {
		Ftv_sec  X__kernel_time_t
		Ftv_nsec int64
	}
	Fit_value struct {
		Ftv_sec  X__kernel_time_t
		Ftv_nsec int64
	}
}

type Itimerval = struct {
	Fit_interval struct {
		Ftv_sec  X__kernel_time_t
		Ftv_usec X__kernel_suseconds_t
	}
	Fit_value struct {
		Ftv_sec  X__kernel_time_t
		Ftv_usec X__kernel_suseconds_t
	}
}

type X__kernel_timespec = struct {
	Ftv_sec  X__kernel_time64_t
	Ftv_nsec int64
}

type X__kernel_itimerspec = struct {
	Fit_interval struct {
		Ftv_sec  X__kernel_time64_t
		Ftv_nsec int64
	}
	Fit_value struct {
		Ftv_sec  X__kernel_time64_t
		Ftv_nsec int64
	}
}

// legacy timeval structure, only embedded in structures that
// traditionally used 'timeval' to pass time intervals (not absolute
// times). Do not add new users. If user space fails to compile
// here, this is probably because it is not y2038 safe and needs to
// be changed to use another interface.
type X__kernel_old_timeval = struct {
	Ftv_sec  X__kernel_long_t
	Ftv_usec X__kernel_long_t
}

// Here we must cater to libcs that poke about in kernel headers.

type Sigset_t = uint64         /* signal.h:16:23 */
type X__sighandler_t = uintptr /* signal-defs.h:19:22 */
type X__sigrestore_t = uintptr /* signal-defs.h:22:23 */

// Here we must cater to libcs that poke about in kernel headers.

type Sigaction = struct {
	Fsa_handler  X__sighandler_t
	Fsa_flags    uint64
	Fsa_restorer X__sigrestore_t
	Fsa_mask     Sigset_t
}

type Sigaltstack = struct {
	Fss_sp    uintptr
	Fss_flags int32
	Fss_size  Size_t
}

type Stack_t = Sigaltstack /* signal.h:128:3 */

var _ int8 /* gen.c:2:13: */
